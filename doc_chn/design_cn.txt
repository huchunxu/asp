
		TOPPERS/ASP内核
		设计笔记

		版本: Release 1.7.0
		最后更新: 2011年3月31日(完成中)

本文档为TOPPERS/ASP内核的设计笔记,尚在完成中,还有诸多疏漏敬请谅解.由华中
科技大学瑞萨高级嵌入式控制器实验室组织翻译制作,主要参与人:任慰,王彦明,
方华启,汪卓

----------------------------------------------------------------------
TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2005-2011 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
对于以上著作权,用户只要符合以下的(1)－(4)条件,或者符合Free Software
Foundation机构公布 的GNU General Public License第2版中记述的条件,著作权
所有者将无偿同意本软件(含本软件修正品,以下同)的使用,复制,修改及再分发(
以下统称为使用).

(1).以源代码形式使用本软件时,须原封不动地把著作权申明,使用条件及以下的无
	保障规定放入源代码中.

(2).以程序库等能被其它软件调用的形式再分发时,须在再分发说明书(使用说明等
	)中,写入 上述的著作权申明,使用条件及以下的无保障规定.

(3).把本软件嵌入机器等,以不能被其它软件调用的形式使用本软件时,须满足以下
	条件中的一条.
	(a).再分发时使用书(使用说明等)中,须写入上述著作权申明,使用条件及以下
	的无保障规定.
	(b).以其它形式再分发本软件时,须向TOPPERS协会报告. 

(4).因使用本软件而引起的直接或间接的损失,均不得向上述著作权所有者及
	TOPPERS协会要求承担责任.

本软件以无保障方式提供给社会.上述著作权所有者及TOPPERS协会对本软件及能
否使用本软件的 探讨均不负任何责任.同时,对因使用上述软件而引起的直接或间
接的损失,均不负任何责任.

 $Id: design.txt 2068 2011-05-06 13:39:26Z ertl-hiro $
----------------------------------------------------------------------

@ 目录

# TOPPERS/ASP内核实现设计方针
# 系统状态与上下文的实现
	- 内核的运行状态与非运行状态
	- 任务上下文与非任务上下文
	- 全中断锁定状态与全中断锁定解除状态
	- CPU锁定状态与CPU锁定解除状态
	- 中断优先级屏蔽
	- 切换禁止状态与切换允许状态
	- 切换保留状态
# 任务状态的管理与调度
	- 任务状态的管理
	- 任务调度器
# 任务切换处理的实现(*未完成)
	- 需要进行任务切换的时刻
	- 任务切换器的构造
# 任务异常处理机能的实现
	- 任务异常处理例程的调用条件与系统状态(由规范确定)
	- 任务异常处理例程调用相关处理
	- 需要准备任务异常处理的时刻
	- 任务异常处理例程调用前的处理
	- 关于在call_texrtn中调用dispatch的处理
# CHECK宏定义与goto语句的使用
	- CHECK宏定义与其使用方法
	- 设计意图
	- 使用CHECK宏定义应具备的条件
	- CHECK宏定义不会产生问题的根据
# ext_tsk,ext_ker的返回值
# 关于内核数据结构的volatile声明 
# 强制类型转换引发的编译警告
# 优先级数据队列机能(未完成)
# 性能评价用系统时刻参照机能
	- 必要性与用途
	- API规范
	- 实现
# 任务异常处理禁止标志enatex的实现理由


@ TOPPERS/ASP内核实现的设计方针

TOPPERS/ASP内核(以下简称ASP内核)是一个为TOPPERS新一代内核的出发点的实时
内核.TOPPERS新一代内核规范中记述了TOPPERS新一代内核的设计方针和ASP内核
的适用领域及设计方针.

虽然以下是对ASP内核实现设计方针的相关说明,但这和规范设计方针有着一定的
联系,无法和规范设计方针完全分离开来.

TOPPERS/ASP内核实现设计方针如下.

(1) 重视代码的易读性和易改造性

代码易读性是开源软件品质的最重要指标.具有良好易读性的开源软件可使熟悉该
软件的开发者迅速增加,从而更早地发现软件中存在的问题,并可充实该软件的支
持机制.另外,代码易读性不仅可以简化设计,而且可以提高设计可靠性.再者,作为
用于技术人员教育的教材,代码易读性也是非常重要的.

代码易改造性不仅意味着可以更方便地根据目标系统的要求更改代码,也有利于进
行整体型开发.作为TOPPERS新一代内核基石的,ASP内核具有良好的易改造性也是
继续开发TOPPERS新一代内核的必要条件.

(2) 良好的可移植性 

由于嵌入式系统中的目标硬件多种多样,可移植性就成为了一个相当重要的特征.在
兼顾执行效率的同时,应将硬件抽象化,并将依赖于目标系统部分(目标依赖部分)和
不依赖于目标系统部分(目标非依赖部分)分离开来.另外,依赖于开发环境的部分(
编译器等)也应进行分离.

(3) 良好的可验证性

为了确保可靠性,应采用易于验证的实现.

具体而言,服务调用中大部分处理都处于全中断禁止状态下,也就是说在执行服务调
用的过程中不允许中断发生.这样的构造有利于提高代码易读性和易改造性,但同
时也牺牲了中断响应的速度.考虑到受此影响的应用只是少数,所以不得不作出此
牺牲.

另外,通过条件编译增加了内核的可配置性,这一方面使得优化更趋于细节化,另一
方面也增加了需要验证的情况,所以还是应尽可能地减少可配置的地方.

(4) 执行性能与内存使用量的考量

在实现时,在满足上述方针的基础之上,应追求更高的执行性能和更少的内存使用
量.在提高性能时,相对于平均性能的提高,应更注重最坏情况下性能的提高.

虽然代码易读性是十分重要的,但并非应通过使用低效率的算法来提高代码易读性,
而还是应采用高效率的算法.为了提高可移植性,ASP内核的大部分代码都是采用C
语言编写,性能无法与汇编代码相比较.

关于内存的使用量,虽然降低RAM使用量是设计时的重点,但是为了兼顾上述设计方
针,也并不是一味降低内存使用量.

(5) 可裁剪性的考量

为了适应各种规模的系统,ASP内核具有良好的可裁剪性.特别是在小规模系统上应
用时,应尽可能将所使用不到内核机能所占用的内存使用量减到最小.

具体而言,假设将内核和应用链接为一个装载模块(load module),将内核以函数为
单位生成相应的内核库,从而链接时仅会链接应用所使用到的函数.虽然这也算作一
种系统配置,但此方法与利用条件编译进行系统配置是不同的,其所带来的验证工
作的增加是较小的.

另外,减少固有RAM使用量,应将可以放在堆栈里的信息尽可能的存储在堆栈中.

@ 系统状态与上下文的实现

本章就<TOPPERS新一代内核规范>中<2.5 系统状态与上下文>中所规定的系统状态
与上下文的实现方法作相关说明.

* 内核的运行状态与非运行状态

为了管理内核的运行状态,设置内核运行状态标志(kerflg).kerflg被启动模块初
始化为false(＝0).在内核运行开始时其值变为true,在内核结束时其值变为false.

----------------------------------------
bool_t	kerflg = false;
----------------------------------------

kerflg的值通过sns_ker获取.在内核的非运行状态下不保证也没有必要保证除
sns_ker以外的服务调用的正常运行,所以在内核的非运行状态下其他服务调用不
会参照kerflg.

* 任务上下文与非任务上下文

任务上下文与非任务上下文的切换由目标硬件以及目标依赖部分负责.用于 判别当
前系统处于何种上下文中的函数(sense_context)也由目标依赖部分实现 .

* 全中断锁定状态与全中断锁定解除状态

全中断锁定标志由目标依赖部分负责管理,系统切换到全中断锁定状态的宏
(SIL_LOC_INT)以及返回原状态的宏(SIL_UNL_INT)在SIL的目标依赖部分中实现.
判别系统是否处于全中断锁定状态下的机能由于没有必要,所以不必实现.

由于不必保证除sns_ker和ext_ker以外的服务调用在在全中断锁定状态下的动作,
所以在这些服务调用中不必判断系统当前是否处于全中断锁定状态.

* CPU锁定状态与CPU锁定解除状态

CPU锁定标志由目标依赖部分负责管理,锁定CPU的函数
(t_lock_cpu/i_lock_cpu/x_lock_cpu)和解除CPU锁定状态的函数
(t_unlock_cpu/i_unlock_cpu/x_unlock_cpu)以及判别系统当前是否处于CPU锁定
状态的函数(t_sense_lock/i_sense_lock/x_sense_lock)由目标依赖部分实现.

* 中断优先级屏蔽

中断优先级屏蔽由目标依赖部分负责管理,中断优先级屏蔽设定函数
(t_set_ipm/i_set_ipm/x_set_ipm)和参照函数(t_get_ipm/i_get_ipm/x_get_ipm)
由目标依赖部分实现.

当系统运行在任务上下文中时,为了能快速地判别系统是否处于中断优先级屏蔽全
解除状态,设置相应的标志(ipmflg).

ipmflg在内核初始化时初始化为false.由于在非任务上下文中系统不可能处于中
断优先级屏蔽全解除状态,不必使用该标志,也不必更新该标志.

----------------------------------------
bool_t	ipmflg;
----------------------------------------

* 切换禁止状态与切换允许状态

为了管理切换禁止状态,设置相应的标志(disdsp).disdsp在内核初始化时初始化
为false.

----------------------------------------
bool_t	disdsp;
----------------------------------------

! 从与ipmflg和dspflg的整合来看,更好的做法不使用disdsp而使用enadsp(其值
为disdsp的反码).

* 切换保留状态

当系统处于非任务上下文中,CPU锁定状态,非中断优先级屏蔽全解除状态,切换禁
止状态这四种状态中的任一一种或者多种之下时,统称系统处于切换保留状态.

当系统处于任务上下文中时,为了能快速判别当前是否处于切换保留状态,设置相
应的标志(dspflg),该标志表示当前系统是否处于中断优先级屏蔽全解除状态,和
切换允许状态(非切换禁止状态).也即,<dspflg == (ipmflg && !disdsp)>.

dspflg在内核初始化时被初始化为true.在任务上下文中,当变更中断优先级屏蔽和
中断禁止标志后,dspflg也会随之改变.在非任务上下文中,系统通常都处于切换保
留状态之下,不必使用该标志,也不必更新该标志.

----------------------------------------
 bool_t	dspflg;
----------------------------------------


@ 任务状态的管理与调度	
* 任务状态的管理

任务管理块(TCB)中负责管理任务状态的成员(tstat)其值代表任务处于以下任意一
种状态中.

　# 就绪状态
　# 休眠状态
　# (狭义的)等待状态
　# 强制等待状态
　# 二重等待状态

当任务就绪时,是保持就绪状态还是直接运行并不由tstat决定,而是由指向当前任
务管理块的指针决定(p_runtsk).如果没有需要运行的任务,则p_runtsk为NULL.

----------------------------------------
 TCB	*p_runtsk;
----------------------------------------

p_runtsk在内核初始化时初始化为NULL,并由任务切换器更新.当服务调用需获取
当前任务的相关信息时,使用p_runtsk.

* 任务调度器

任务调度器在处于就绪状态的任务中选择一个优先顺位的最高的任务(称之为最高
优 先顺位任务),并将指针(p_schedtsk)指向该任务的TCB.

----------------------------------------
TCB	*p_schedtsk;
----------------------------------------

对于任务调度器,需要让其知道哪些任务进入了就绪状态.因此为任务调度器准备了
下面两个函数.

　# 通知任务调度器某个任务进入了就绪状态(make_runnable)
　# 通知任务调度器某个任务从就绪状态迁移到其他状态(make_non_runnable)

另外,从处理效率的角度考虑,准备了下面两个函数用以直接操作任务就绪队列并进
行任务调度,而不经上述两个函数.

　# 变更任务的优先级(change_priority)
　# 旋转就绪任务队列(rotate_ready_queue)


@ 任务切换处理的实现

* 需要进行任务切换处理的时刻

当系统不处于任务切换保留状态下并且当前任务(p_runtsk)和最高优先顺位任务
(p_schedtsk)不一致时需要进行任务切换.具体情况,有以下三种.

(1) 当前任务无法继续执行

当调用服务调用使当前任务进入广义的等待状态时,或者结束当前任务时,需要进
行任务切换处理.

(2) 最高优先顺位任务发生变化

当调用服务调用启动任务,解除任务等待,变更任务优先级,旋转任务队列的顺序时
,如果此时系统不处于切换保留状态时,需要进行任务切换处理.

(3) 切换保留状态被解除时

切换保留状态是系统处于非任务上下文,CPU锁定状态,非中断优先级屏蔽全解除状
态和切换禁止状态的统称.当这些状态发生迁移时,需要进行任务切换处理.具体时
刻如下.

(3-1) 当非任务上下文切换到任务上下文时

从中断处理函数或者CPU异常处理函数返回到任务时,需要进行任务切换处理.

(3-2) 解除CPU锁定状态

在CPU锁定状态下,是无法调用引发上述(1),(2)两种情况中系统服务,所以当解除
CPU锁定状态时,不需要进行任务切换处理.

(3-3) 中断优先级屏蔽全部解除

当中断优先级屏蔽经chg_ipm全部解除时,需要进行任务切换处理.

当任务结束,从任务异常处理例程,中断处理函数,中断服务例程,定时器处理函数
,CPU异常处理函数返回时,可能会解除全部中断优先级屏蔽,此时需要任务切换处
理.但当从中断服务例程或定时器处理函数返回后,系统仍处于非任务上下文中,也
既处于切换保留状态之下,所以不需要进行任务切换处理.

(3-4) 允许任务切换

当允许任务切换(ena_dsp)时,需要进行任务切换处理的.

另外,当任务结束后或者从任务异常处理例程返回后,可能允许任务切换,此时需要
进行任务切换处理.

当内核进入运行状态时,也应立即需要进行任务切换处理.

* 任务切换器的构造

任务切换器的主要机能是将即将被切换出去的任务的上下文(处理器的通用寄存器)
保存到任务堆栈中,并将即将运行的任务的上下文从任务堆栈中恢复.哪些寄存器的
内容应该被保存/恢复,根据任务切换进行时情况有所不同,具体如下.

# 当任务被中断(或者CPU异常)剥夺执行时,必须保存所有寄存器的内容,并且
  在返回后应恢复所有寄存器的内容.

# 当任务主动进行任务切换处理时(调用相关服务调用),仅需要保存暂存寄存器
  (caller saved register)以外寄存器的内容即可,当任务恢复执行时,也不用恢复
  暂存寄存器的内容.

# 任务结束时,不需要保存任何寄存器的内容.

# 任务开始时,也不需要对任何寄存器进行恢复.

为了使得必须要保存/恢复的寄存器尽可能的少,任务切换处理由三步构成,既(a)
保存上下文,(b)选择下一个应运行的任务,(c)恢复上下文.这里(a)和(c)的中处理
,根据任务切换进行时情况分别准备.具体如下.

(a) 保存上下文
	(a-1) 任务主动进行任务切换处理时保存上下文(dispatch)
	(a-2) 中断处理函数出口处保存上下文(ret_int)
	(a-3) CPU异常处理函数出口处保存上下文(ret_exc)
	(a-4) 任务结束时的处理(exit_and_dispatch)
	(a-5) 内核进入运行状态时处理(start_dispatch)
(b) 选择下一个应执行的任务(调度器本体，dispatcher)
(c) 上下文的恢复处理
	(c-1) 任务主动进行任务切换处理时恢复上下文(dispatch_r)
	(c-2) 中断处理函数出口处的恢复上下文(ret_int_r)
	(c-3) CPU异常处理函数出口处的恢复上下文(ret_exc_r)
	(c-4) 任务开始时用到的函数(start_r)


@ 任务异常处理机能的实现

* 任务异常处理例程的调用条件和系统状态(由规范确定)

同时具备以下6个条件时才可以调用任务异常处理例程.

　# 允许任务异常处理
　# 任务异常请求不为0
　# 任务处于运行状态
　# 进入任务上下文中
　# 中断优先级屏蔽全部解除
　# 解除CPU锁定

任务异常处理例程启动和返回时系统状态的相关规范如下

				CPU锁定		   中断优先级       切换禁止
				标志             屏蔽            标志
------------------------------------------------------------
[任务异常处理例程]
触发条件     	 解除			全解除			任意
开始时的处理	保持不变		保持不变		保持不变
返回前		 原则上解除(*1)	  原则上全解除(*1)	复原
返回时的处理	 解除		    全解除		    复原(*4)
------------------------------------------------------------

* 任务异常处理例程调用相关处理

调用任务异常处理例程时的相关处理流程如下,该函数在CPU锁定状态下被调用.

----------------------------------------
void
call_texrtn(void)
{
	TEXPTN	texptn;

	texptn = p_runtsk->texptn;
	p_runtsk->texptn = 0U;

	禁止任务异常处理
	保存切换禁止标志

	解除CPU锁定
	调用任务异常处理例程
	CPU锁定

	解除全部中断优先级屏蔽
	恢复切换禁止标志
	禁止任务异常处理 … (*2)

	有必要的话则进行任务切换 … (*1)

	允许任务异常处理
}
----------------------------------------

(*1)中当中断优先级屏蔽全部解除或恢复切换禁止标志时,可能解除切换保留状态,
因此需要进行任务切换.

(*2)中在任务切换前禁止任务异常处理的理由,请参考<关于在call_texrtn中调用
dispatch>一节.

* 需准备任务异常处理的时刻

由于任务异常处理例程的触发需要同时具备前述的6个条件,当这6个条件任意一
个被新近满足时都必须准备任务异常处理.

下面,讨论这6个条件任意一个被新近满足时的情况.

(1) 允许任务异常处理

当调用ena_tex时或者从任务异常处理例程中返回时,将允许任务异常处理,此时需
要准备任务异常处理

(2) 任务异常请求不为0

通过调用(ras_tex, iras_tex)发起任务异常请求时,对应任务的异常请求不为0,
此时需要准备任务异常处理.但是对于在非任务上下文中执行的iras_tex,由于不
满足条件(4),所以无需准备任务异常处理.

(3) 任务处于运行状态

当经由任务切换器,任务进入运行状态时,需要准备任务异常处理.

(4) 进入任务上下文中

当从中断处理函数或CPU异常处理函数返回并恢复到任务上下文时,需要准备任务
异常处理.

(5) 中断优先级屏蔽全部解除

通过调用chg_ipm解除全部中断优先级屏蔽时,需要准备任务异常处理.

当任务结束或者从任务异常处理例程,中断处理函数,CPU异常处理函数返回时可能
会解除全部中断优先级屏蔽.

当任务的结束并切换到新的任务时,新任务所对应的任务异常处理的准备工
作在任务切换后进行.

(6) 解除CPU锁定

当调用unl_cpu,iunl_cpu解除CPU锁定状态时,需要准备任务异常处理.但是对于在
非任务上下文中执行的iunl_cpu,由于不满足条件(4),所以无需准备任务异常处理
.

当任务结束或者从任务异常处理例程,中断处理函数,中断服务例程,定时器处理函
数,CPU异常处理函数返回时可能会解除CPU锁定状态.

但是,对于中断服务例程和定时器处理函数,返回时仍处于非任务上下文中,由于不
满足条件(4),所以无需准备任务异常处理.

当任务的结束并切换到新的任务时,新任务所对应的任务异常处理的准备工
作在任务切换后进行.

根据上述讨论,归并重复内容,将需要准备任务异常处理的情况整理如下.

(a) 允许任务异常处理(ena_tex)… (1)
(b) 任务异常处理例程的出口 … (1)(5)(6)
(c) 发起任务异常处理请求(ras_tex)… (2)
(d) 任务切换后的处理 … (3)(5)(6)
	(d-1) dispatch_r
	(d-2) ret_int_r
	(d-3) ret_exc_r
	(d-4) start_r
(e) 中断处理函数的出口 … (4)(5)(6)
(f) CPU异常处理函数的出口 … (4)(5)(6)
(g) 变更中断优先级屏蔽(chg_ipm)… (5)
(h) 解除CPU锁定状态(unl_cpu)… (6)

对于(d-4),由于任务开始运行后并不会立即允许任务异常处理(直到任务调用
ena_tex),不满足条件(1),所以无需准备任务异常处理.

关于(h),由于在处于CPU锁定状态下,无法完全新近满足其他5个条件,所以无需准备
任务异常处理.

在CPU锁定状态下,无法调用ena_tex(允许任务异常处理),ras_tex和iras_tex(请
求任务异常处理)和chg_ipm(变更中断优先级屏蔽),也无法进行任务切换处理.虽
然在CPU锁定状态下,可以从任务异常处理例程中返回,但返回后,CPU锁定状态即
被解除.在CPU锁定状态下从中断处理函数返回与此同样.

在CPU锁定状态下从CPU异常处理函数返回可能会存在一些问题.具体可以分为CPU
锁定状态下发生CPU异常和非CPU锁定状态下发生CPU异常两种情况讨论.如果是在
非CPU锁定状态下,从CPU异常处理函数返回时将解除CPU锁定状态,其情况与从中断
处理函数返回一致.而在CPU锁定状态下时,由于被触发的CPU异常处理函数在内核
管理之外,其中条件(1),(3)和(5)是无法新近满足的.在CPU异常处理函数的执行前
后(4 会被保存和恢复,返回后条件(1)和(5)恢复到CPU异常发生前的状态,也不会
被新近满足.

* 任务异常处理例程调用前的处理

根据上述对需要准备任务异常处理的时刻的探讨,这里对任务异常处理例程调用前
的相关处理的实现进行说明.

(a) 允许任务异常处理(ena_tex)

任务调用ena_tex后,对于调用任务而言,已经满足了<任务处于运行状态>和<在任
务上下文中>,ena_tex使得<允许任务异常处理>被满足,而<CPU不处于锁定状态>又
是ena_tex的前提条件.所以在ena_tex中只要满足<任务异常请求不为0>和<中断优
先级屏蔽全部解除>,就应当调用任务异常处理例程.

ena_tex中的处理如下(除去错误处理).

----------------------------------------
		p_runtsk->enatex = true;
		if (p_runtsk->texptn != 0U && ipmflg) {
			call_texrtn();
		}
----------------------------------------

(b) 任务异常处理例程出口处理

在任务异常处理例程的出口处理处(既call_texrtn的后半部分),对于当前任务,已
经满足了<任务处于运行状态>和<在任务上下文中>,而在出口处又满足了<中断优
先级屏蔽全部解除>,<允许任务异常处理>和<CPU不处于锁定状态>.所以只要<任务
异常请求不为0>,就应当调用任务异常处理例程.

但此时如简单调用call_texrtn,将造成call_texrtn的递归调用,可能会造成任务堆
栈的溢出.所以此时,如<任务异常请求不为0>,应继续在call_texrtn内循环.

修正后的call_texrtn函数大致流程如下.

----------------------------------------
void
call_texrtn(void)
{
	TEXPTN	texptn;

	保存切换禁止标志 … (*3)
	禁止任务异常处理 … (*6)

	do {
		texptn = p_runtsk->texptn;
		p_runtsk->texptn = 0U;

		解除CPU锁定
		调用任务异常处理例程
		锁定CPU

		解除全部中断优先级屏蔽
		恢复切换禁止标志 … (*4)
		禁止任务异常处理 … (*2)

		必要时进行任务切换处理 … (*1)
	}  while (p_runtsk->texptn != 0U);

	允许任务异常处理 … (*5)
}
----------------------------------------

由于会在(*4)处恢复切换禁止标志,切换禁止标志的保存放在循环体以外的(*3)处
效率更高.

由于(*2)处会禁止任务异常处理,所以(*6)处的处理放在循环外面进行效率更高.
任务异常处理例程结束后的允许任务异常处理放在循环外面的(*5)处效率更高.

(c) 请求任务异常处理(ras_tex)

当通过ras_tex发起任务异常处理请求的对象任务为调用任务自身时,已经满足了<
任务处于运行状态>和<在任务上下文中>.ras_tex使得<任务异常请求不为
0>(ras_tex的参数rasptn如果为0则报错),而<CPU不处于锁定状态>为ras_tex的前
提条件.所以只要满足对象任务为调用任务自身,<允许任务异常处理>,<中断优先
级屏蔽全部解除>,就应当调用任务异常处理例程.

ras_tex中的处理(除去错误处理)如下.

----------------------------------------
		p_tcb->texptn |= rasptn;
		if (p_tcb == p_runtsk && p_runtsk->enatex && ipmflg) {
			call_texrtn();
		}
----------------------------------------

(d-1) dispatch_r

在dispathc_r中,对于即将恢复运行的任务,已经满足了<任务处于运行状态>和<在
任务上下文中>.而且,在CPU锁定状态下不会运行到dispath_r,因此满足了<CPU不
处于锁定状态>.所以只要满足<允许任务异常处理>,<任务异常请求不为0>,<中断
优先级屏蔽全部解除>,就应当调用任务异常处理例程.

所以,在任务上下中进行任务切换的处理dispatch做如下修正.

----------------------------------------
void
dispatch(void)
{
	………

  dispatch_r:
	从任务堆栈中恢复除暂存寄存器外的所有寄存器
	calltex();
}
----------------------------------------

calltex判断当前是否满足<允许任务异常处理>,<任务异常请求不为0>,<中断优先
级屏蔽全部解除>.如果满足则调用call_texrtn.

----------------------------------------
void
calltex(void)
{
	if (p_runtsk->enatex && p_runtsk->texptn != 0U && ipmflg) {
		call_texrtn();
	}
}
----------------------------------------

(d-2) ret_int_r

ret_int_r为在中断处理函数出口处恢复任务上下文的相关处理.对于ret_int_r中
即将恢复运行的任务,已经满足了<任务处于运行状态>和<在任务上下文中>.而且,
在CPU锁定状态下不会运行到ret_int_r,因此满足了<CPU不处于锁定状态>.所以只
要满足<允许任务异常处理>,<任务异常请求不为0>,<中断优先级屏蔽全部 解除>,
就应当调用任务异常处理例程.

所以,在中断处理函数出入口处理中做如下修正.

----------------------------------------
void
<中断出入口处理>(void)
{
		………

			  ret_int_r:
			  	从任务堆栈中恢复除暂存寄存器外的所有寄存器
			 	 calltex();
			}
		………
}
----------------------------------------

(d-3) ret_exc_r

ret_exc_r为在CPU异常处理函数出口处恢复任务上下文的的相关处理.

由内核管理的CPU异常处理函数出口处理(ret_exc)与中断处理函数出口处理
(ret_int)一致.在CPU锁定状态下发生的CPU异常处理函数在内核管理之外,不会进
行任务切换,也不会运行到ret_exc.因此对于ret_exc_r中即将恢复运行的任务,满
足<CPU不处于锁定状态>.

所以,在CPU异常处理函数的出入口处理中与中断处理函数出入口处理相同,做如下
修正.

----------------------------------------
void
<CPU异常的出入口处理>(void)
{
			………

				  ret_exc_r:
					从任务堆栈中恢复除暂存寄存器外的所有寄存器
					calltex();
				}
			………
}
----------------------------------------

(e) 中断处理函数的出口处理

当直接从中断处理函数返回被中断的任务时,对于即将返回的任务,已经满足了<任
务处于运行状态>和<在任务上下文中>.而且,在CPU锁定状态下不会执行中断处理
函数,因此满足了<CPU不处于锁定状态>.所以只要满足<允许任务异常处理>,<任务
异常请求不为0>,<中断优先级屏蔽全部解除>,就应当调用任务异常处理例程.

如果中断处理函数前后这些条件发生了变化,造成这些变化发生的情况或者当前运
行任务发生了变化或者在中断处理函数中调用iras_tex.中断处理函数中不能调用
ena_tex和chg_ipm,因此<允许任务异常处理>和<中断优先级屏蔽全部解除>这两个
条件在中断处理函数中不会发生变化.

对于上述两种情况,当前运行任务发生变化时,相应的处理在ret_int_r中实现.当
在中断处理函数中调用iras_tex时,regflg将为true,所以任务异常处理例程的准
备工作应在regflg为true时才进行.

在上面修正过的中断处理函数出入口处理之上,再作如下修正.

----------------------------------------
void
<中断的出入口处理>(void)
{
	………

	if (中断是否发生在任务上下文中) {
		………
		if (reqflg) {
			………

			  ret_int_r:
				从任务堆栈中恢复除暂存寄存器外的所有寄存器
			}
			calltex();
		}
	}
	………
}
----------------------------------------

(f) CPU异常处理函数的出口处理

由内核管理的CPU异常处理函数出口处理与中断处理函数出口处理一致.

在内核管理外的CPU异常处理函数中,不可能发生被执行任务的切换,也不能调用
iras_tex和ena_tex,所以无法满足调用任务异常处理例程的前提条件,无需做调用
任务异常处理的准备.

所以,在CPU异常处理函数的出入口处理中与中断处理函数出入口处理相同,作如下
修正.

----------------------------------------
void
<CPU异常的出入口处理>(void)
{
		………
		if (CPU异常是否发生在任务上下文中) {
		………
			if (reqflg) {

				  ret_exc_r:
					从任务堆栈中恢复除暂存寄存器外的所有寄存器
				}
				calltex();
			}
		}
		………
}
----------------------------------------

(g) 变更中断优先级屏蔽

当chg_ipm被调用时,对于调用任务,已经满足了<任务处于运行状态>和<在任务上
下文中>.而CPU处于非CPU锁定状态又是chg_ipm的前提条件.只要chp_ipm的参数为
TIPM_ENALL,且满足<允许任务异常处理>,<任务异常请求不为0>,就应当调用任务
异常处理例程.

chg_ipm中的处理如下.

----------------------------------------
	t_set_ipm(intpri);
	if (intpri == TIPM_ENAALL) {
		ipmflg = true;
		任务切换处理
		if (p_runtsk->enatex && p_runtsk->texptn != 0U) {
			call_texrtn();
		}
	}
----------------------------------------

当调用dispatch进行任务切换时,在dispatch的出口处会进行调用任务异常处理例
程的处理,这里处理是重复无必要的.但为了降低代码的复杂度,即使调用了
dispatch,此处的处理仍然保留.

* 关于call_texrtn中调用dispatch的相关处理

dispatch_r中(在目标依赖部分中通过calltex)存在对call_texrtn的调用
,call_texrtn中也会存在对dispatch的调用,从而可能形成反复互相调用.二者之
间的互相调用在实现中并不会造成问题,理由如下.

在非切换保留状态下,任务异常处理例程可能会使内核进入切换保留状态,并进行
相关处理使得需要进行任务切换,但在返回前又不解除切换保留状态.针对这种情
况,call_texrtn在解除切换保留状态后(恢复之前的相关标识),调用dipatch.也即
,这一系列处理是对任务异常处理例程不解除切换保留状态的补救措施,以下称之
为<补救情况>.

与此相对应的,考虑在任务异常处理例程的最后正确解除切换保留状态后返回的情
况.在这种情况下,在解除切换保留状态的相关服务调用中(ena_dsp,chg_ipm),将
会调用dispatch进行任务切换.这种情况称之为<正常情况>.

<正常情况>和<补救情况>的不同之处在于,在<正常情况>下执行顺序为
call_texrtn->任务异常处理例程->服务调用->dispatch,而在<补救情况
>,dispatch由call_texrtn直接调用.相比之下,<补救情况>占用更少的的堆栈.
也即意味着,只要正常情况下,堆栈能满足使用需求,那么在<补救情况>下就更不存
在问题.

<正常情况>和<补救情况>,除上述不同外,其他都是相同的.具体而言,call_texrtn
应在重新允许任务异常处理之前(置p_runtsk->enatex为true)调用dispatch.如果
在允许任务异常处理后,调用dispatch,在其返回处dispatch_r中可能会再次进行
任务异常处理,此时对于<补救情况>,堆栈使用量将增加.

任务异常处理例程可能在继续允许任务异常的状态下返回,此时在call_texrtn所调
用的dispatch的返回处dispatch_r中可能会再次进行任务异常处理.在这种情况下,
堆栈的使用量比在任务异常处理例程最后解除切换保留状态再返回的情况少,但是
相比禁止任务异常处理后解除解除切换保留状态再返回的情况多.为了避免这种情
况,call_texrtn中在调用dispatch之前,先置p_runtsk->enatex为false.


@  CHECK宏定义与goto语句的使用

在ASP内核的实现中,为了能检出服务调用的静态错误,使用了一系列以"CHECK_"开
头的宏定义(统称为CHECK宏定义).

CHECK宏定义中含有goto语句.按照MISRA-C规范,goto语句是被禁止使用的,且也有
很多意见建议不应使用goto语句.另外也有意见认为在宏定义中使用goto语句会产
生问题的意见.

此处对CHECK宏定义中使用goto语句的设计意图以及使用的条件,还有CHECK宏定义
的使用不会产生可靠性方面问题进行论述.

在ASP内核的实现上,仅在CHECK宏定义中使用了goto语句(一部分系统服务中,以其
他形式使用了goto语句).

* CHECK宏定义及其使用方法

kernel/check.h中定义了25个CHECK宏定义,其形式皆如下所示,这里,XXXXX为代表
某种错误的字符串.

----------------------------------------
#define CHECK_XXXXX(<……>) {				\
	if (<报错条件>) {						\
		ercd = <错误码>;			    	\
		goto error_exit;					\
	}										\
}
----------------------------------------

许多服务调用都使用到了这些CHECK宏定义,具体使用方式如下.

----------------------------------------
ER
<服务调用名>(……)
{
	<局部变量的声明>
	ER		ercd;

	LOG_XXX_YYY_ENTER(……);
	CHECK_XXXXX(……);
	CHECK_YYYYY(……);

	<服务调用函数本体>

  error_exit:
	LOG_XXX_YYY_LEAVE(……);
	return(ercd);
}
----------------------------------------

上例中使用了两个CHECK宏定义,当然,也有使用一个CHECK宏定义和使用三个以上的
CHECK宏定的情况.另外,在多个CHECK宏定义之间有时候也使用局部变量传递数据(
例如,ter_tsk的处理函数).

* 设计意图

CHECK宏定义的设计意图,是使服务调用中针对静态错误的检错代码更加的模式化,
使代码更加简洁易读,以及减少编码错误.

但如果不使用CHECK宏定义,则可以将上面提到的服务调用作如下更改.

----------------------------------------
ER
<服务调用名>(……)
{
	<局部变量的声明>
	ER		ercd;

	LOG_XXX_YYY_ENTER(……);
	if (<XXXXX的报错条件>) {
		ercd = <XXXXX的错误码>;
	}
	else {
		if (<YYYYY的报错条件>) {
			ercd = <YYYYY的错误码>;
		}
		else {

			<服务调用的函数本体>

		}
	}
	LOG_XXX_YYY_LEAVE(……);
	return(ercd);
}
----------------------------------------

在知道CHECK宏定义的功能的前提之下,显然原来的代码更具易读性.

但是如果这样,在CHECK宏定义中使用goto语句是不可避免的.

* 使用CHECK宏定义的条件

使用CHECK宏定义时必须满足以下两个条件.

(1) CHECK宏定义须放在服务调用开始部分的日志处理和临界区入口之间,并且应
    在逻辑判断最外层.

(2) 标签error_exit须放在临界区出口和末尾部分的日志处理之间,并且应在逻辑
	判断最外层.

* 不会产生问题的根据

我们认为这样使用goto语句是不会对软件的可靠性造成任何影响的.MISRA-C等编
码规范禁用goto语句的根据是认为goto语句会造成可靠性方面的问题.

但是,MISRA-C的文档中对禁止使用goto语句的原因并未明确说明,对该原因的推测
如下.

# 使处理流程复杂化,不容易了解程序意图(或者说让代码成为所谓的面条式代码
  (spaghetti program)).

在CHECK宏定义中的goto语句是为了在有错误发生时强制跳转到地址标签为
error_exit的地方进行错误处理,意图非常明确.但如果这样,下面一点将继续为禁
止使用goto语句的根据.

# 利用goto语句强制跳过某段代码,可能也会跳过一些必要的后续处理.

但是关于这点,只要在满足上述CHECK宏定义使用条件的前提下,发生跳转时并没有
后续一些必要的处理,因此不会对软件的可靠性造成影响.

一个验证不会产生问题的方法是将用不符合编码规范的代码替换为符合编码规范
的等价代码.

按照在<设计意图>一节的描述,可以将含有CHECK宏定义的代码替换为不使用CHECK
宏定义的代码.

对于某个没有对应的else部分的if语句,若在该if语句的执行体的末尾有跳转到同
一代码块内同一层内标签的goto语句,if语句和该标签的之间的代码可以放入对应
if语句的else部分中,从而不使用goto语句.

以下面含有goto语句的代码为例．

----------------------------------------
	{
		/* if语句之前的代码 */
		if (....) {
			/* then语句之后的代码 */
			goto <标签>;
		}
		/* if语句和标签间的代码 */
	  <标签>:
		/* 标签之后的代码 */
	}
----------------------------------------

上述代码对应的不含goto语句的等价代码如下

----------------------------------------
	{
		/* if语句之前的代码 */
		if (....) {
			/* then语句之后的代码 */
		}
		else {
			/* if语句与标签之间的代码 */
		}
		/* 标签之后的代码*/
	}
----------------------------------------

如果有多个符合条件的goto语句,可以从最下面那个goto语句开始自下而上的按照
上述方法替换为不使用goto语句的等价代码.

CHECK宏定义中的goto语句也可以按照上述方法进行替换为不使用goto语句的等价
代码,因此CHECK宏定义的使用不会产生问题.

@ ext_tsk,ext_ker的返回值

在μITRON4.0规范中服务调用ext_tsk是没有返回值的.但是在TOPPERS新一代内核
中ext_tsk是有返回值的,其返回值的类型为ER型,并且如果在非任务上下文中调用
ext_tsk会返回错误E_CTX.

关于这个规范,讨论过好几种方案但均未采用,其理由如下.

# 像JSP内核那样即使检出可能发生的危险但继续执行下去,不符合一些重视可靠性和
  安全性的系统的期望.对于这样的系统,一旦检出可能发生的危险,应尽早处理并恢复.

# ASP内核的最初方案是当检测出有发生危险的可能后立即终止内核,这种方法没有
  留给应用侧进行恢复处理的余地,这并非所期望的.

# 为了保持兼容性,返回类型为void.但这样不容易让使用者注意到规范的变更,并
  且也无法返回其他错误码(比如E_NOSPT).

# 一旦发生错误,引发一种CPU异常.从内核规范的完整性考虑,不采用此种方法.相
  比导入一种CPU异常,当服务调用返回错误时像OSEK/VDX OS规范那样调用相应的
  错误处理钩子函数(error hook),更为有用.

相对于这种变更,也考虑了在CPU锁定状态下或者禁止切换状态下调用ext_tsk错误
返回的方法,但由于任务体中的返回和ext_tsk是不等价的,所以不采用.同时也有与
其他处理单位的返回方法一起整合的意图(例如,CPU锁定状态下中断处理函数返回
时的处理)。

与此相应的,ext_ker的返回值类型也变更为ER型.虽然在ASP内核中ext_ker不会返
回错误,但在HRP内核中ext_ker可能会返回E_OACV错误.

另外,虽然在μITRON4.0规范中有服务调用exd_tsk(没有返回值),但TOPPERS新一代
内核并不支持该服务调用.


@ 关于内核数据结构的volatile声明(临界区出入处理实现的相关限制)

由于可能被其他并行运行的处理单位(中断处理函数,任务等)所访问 ,在内核的数
据结构前增加volatile声明可能是有必要的.实际上也收到过一些问题报告,即原本
在临界区内访问内核数据结构的代码被编译器优化到了临界区之外,从而产生了一
些问题.

虽然对内核所有数据结构都增加上volatile声明有助于系统安全性的提高,但由于
这限制了优化,这也给内核的大小和性能的带来了负面影响.ASP内核中,采用以下方
法,使内核数据结构可以不用增加volatile声明.

ASP内核中,对于可能被并行运行的其他处理单位所改变的数据结构全部放在处于
CPU锁定状态下或者全中断锁定状态下的临界区中访问.为了不是临界区中对内核数
据结构的访问不被编译器优化到临界区外,在临界区的出入处理实现中应使编译器
了解临界区中可能会改变内存上的数据结构.

具体而言,只要将临界区的出入处理用函数来实现,便可抑制编译器对临界区内核
数据结构访问的优化.但是ASP 内核的很多目标依赖部分都是用宏定义或者内联函
数来实现临界区的出入口处理,无法抑制上述的编译器优化.

因此在实现临界区的出入口处理时应想方设法的告诉编译器临界区内的代码可能会
修改内存上的数据结构.GNU环境下可以通过以下几种方法的任意一种来通知编译器
.

(a) 用普通函数(非内联函数)来实现临界区的出入口处理或者出入口处理的实质部
    分(中断禁止/允许处理).

(b) 临界区出入口处理的实质部分是由内联汇编函数实现的,则在该内联汇编函数
	的clobber变量表中增加"memory".

(c) 如果临界区出入口处理的实质部分是通过宏定义或者调用内联函数来实现的
	,则在临界区的入口处理的末尾以及出口处理的开头加上Asm("":::"memory").

需要考虑上述问题的临界区出入处理有以下几个.

	SIL_LOC_INT
	SIL_UNL_INT
	t_lock_cpu, i_lock_cpu, x_lock_cpu
	t_unlock_cpu, i_unlock_cpu, x_unlock_cpu


@ 强制类型转换引发的警告

在用GCC编译内核源文件时,如果使用了配置项-O2,那么有几个地方会出现以下编译
警告(也跟GCC的版本有关系).

warning: dereferencing type-punned pointer will break strict-aliasing rules

这是因为-O2配置项让编译器在遵循strict aliasing rule的前提下进行编译和优
化.如果想让编译器不遵循strict aliasing rule,使用配置项
-fno-strict-aliasing即可.这种方法虽然可以抑制上述编译警告出现,但也使GCC
不能进行以strict aliasing rule为前提的相关优化.

在ASP内核的实现中,可以进行以strict aliasing rule为前提优化.对于由此而产
生的编译警告,可以忽视,其理由如下.

以下述semaphore.c中会产生编译警告的代码为例,进行说明.

	wobj_make_wait((WOBJCB *) p_semcb, (WINFO_WOBJ *) &winfo_sem);

这段代码产生编译警告的直接原因是将&winfo_sem强制转换为(WINFO_WOBJ*) ,本
质原因是这段代码可能有违反strict aliasing rule的赋值语句,从而使以strict
aliasing rule为前提的优化产生错误.

C语言的strict aliasing rule的内容为,对于不兼容的不同数据类型,不能交替使
用访问同一内存区域的赋值语句(如使用,则结果不确定).在上述的例子中,不能交
替使用通过(WINFO_SEM *)型指针和(WINFO_WOBJ*)型指针访问同一内存区域的赋值
语句.另外,虽然不是产生编译警告的原因,也不能交替使用通过(SEMCB *)型指针
和(WOBJCB *)指针访问同一内存区域的赋值语句.

在ASP内核的实现中,semaphore.c中的函数在通过(SEMCB *)型指针和(WINFO *)型
指针访问的同时,不会再通过(WOBJCB *)型指针和(WINFO_WOBJ *)型指针访问同一
内存区域.wait.c中的函数在通过通过(WOBJCB *)型指针和(WINFO_WOBJ *)型指针
访问的同时,也不会再通过(SEMCB *)型指针和(WINFO *)型指针访问同一内存区域
.

对于不遵循strict aliasing rule的赋值语句,在进行以strict aliasing rule为
前提的优化时,可能会产生问题.但不同的编译单位中所进行的的优化彼此不影响 ,
因此不会产生问题.

其他源文件(eventflag.c, dataqueue.c, pridataq.c, mailbox.c, mempfix.c)
中出现的上述警告也与此同理.


@ 优先级数据队列机能(未完成)

* 引入的经过

* API规范

CRE_PDQ(ID pdqid, { ATR pdqatr, uint_t pdqcnt, PRI maxdpri, void *pdqmb });
ER snd_pdq(ID pdqid, intptr_t data, PRI datapri);
ER psnd_pdq(ID pdqid, intptr_t data, PRI datapri);
ER ipsnd_pdq(ID pdqid, intptr_t data, PRI datapri);
ER tsnd_pdq(ID pdqid, intptr_t data, PRI datapri, TMO tmout);
ER rcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri);
ER prcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri);
ER trcv_pdq(ID pdqid, intptr_t *p_data, PRI *p_datapri, TMO tmout);
ER ini_pdq(ID pdqid);
ER ref_pdq(ID pdqid, T_RPDQ *pk_rpdq);

* 实现

<未完成>


@ 性能评价用系统时刻获取机能

* 必要性与用途

ASP内核支持性能评价用系统时刻获取机能,该机能用于测量对ASP内核自身以及在
ASP内核上运行的任务的性能.性能评价用系统时刻精度高于内核系统时刻,其单位
为微秒,但实际精度取决于目标系统,

使用该机能所测量某段代码的运行时间时,先获得执行前性能评价用系统时刻,在
代码执行结束后,再获得性能评价用系统时刻,二个时刻相减即为运行时间.因此常
以相对值的形式使用性能评价系统时刻,而不使用其绝对值.

* API规范

性能评价用系统时刻获取机能使用的数据类型如下

	SYSUTM		性能评价用系统时刻(无符号整数,单位为微秒,位数在32位以上)

在目标非依赖部分SYSUTM型被类型定义为ulong_t型(既unsigned long型),如位数
在32位以上,则由目标定义.

当性能评价用系统时刻超过了SYSUTM型数据的表示范围时(既溢出)会被归零.对于
通过求执行前后两个时刻之差以获得实际运行时间的情况,所测量的运行时间只要
不超过SYSUTM型的表示范围,就不用考虑归零的问题.

当SYSUTM型为32位时,大概71分钟左右会溢出,如通过该机能测量超过71分钟的时间
,测试结果不予保证.

性能评价用系统时刻获取机能的相关服务调用的规范,请参照<TOPPERS新一代内核
规范>的<4.6.1 系统时刻管理>.

* 实现

为了获得以微秒为单位的时刻,需要从提供系统时刻的周期定时器中获得当前计数
器的值(假定定时器为递增计数),并转换成为微秒.将当前内核系统时刻(以毫秒为
单位)乘以1000加上刚才获得的值即用作性能评价用系统时刻.虽然将当前内核系
统时乘以1000容易引起溢出,但不会产生问题.

但是,保证当前内核系统时刻的值和定时器的值连续是不容易.当顺序读取这两个
值时,在两次读取之间,定时器可能发生溢出并引发中断,那么一次获得的是溢出之
前的值,另一次获得的是溢出之后的值,这将导致获得的性能评价用系统时刻是错
误的.

解决这个问题的方法有几个.具体采用什么方法,需根据以下要求来确定.

(1) 能够在大多数目标系统上实现.

(2) 尽可能使服务调用的执行时间保持不变,也即尽可能使服务调用的执行时间不
    因条件的改变而出现大的波动.

(3) 尽可能使服务调用获得时刻相同,也即所获得的时刻不因条件的改变而改变.

(4) 需要调整的参数尽可能的少.

为了满足上述要求,可以采用以下方法.

首先,在禁止所有中断的状态下(NMI除外),按照当前系统时刻,当前定时器的值(第
一次读取),定时器中断请求标志,当前定时器的值(第二次读取)的顺序来读取.由于
禁止所有中断,期间当前系统时刻不会发生变化,所以读取当前系统时刻的顺序可
以改变.第二次读取的定时器值只有在存在定时器中断请求时才有意义,为了满足
要求(2),不管是否存在定时器中断请求,都进行第二次读取.

读取完这些值之后,解除中断禁止状态,并作如下处理.首先,如果存在定时器中断请
求,为了保证第一次读取的定时器值和系统时刻的连续性,需要通过上述所读取的值
获得正确的性能评价用系统时刻.

当存在定时器中断请求时,第一次所读取的定时器值可能是定时器中断请求发生前
的值(溢出前的值)也可能是定时器中断请求发生后的值(溢出后的值).具体是哪种
情况,需要根据第二次读取的定时器值确定.第二次读取的定时器值肯定是定时器中
断请求发生后的值(溢出后的值).如第一次读取的定时器值比第二次读取的定时器
值大,则第一次的值可以推测为定时器发生溢出前的值,那么第一次读取的定时器值
与当前系统时刻是连续的,直接相加即为性能评价用系统时刻.如第一次读取的定
时器值小于等于第二次读取的定时器值,那么第一次的值时定时器可以推测为发生
溢出后的值,需要修正当前系统时刻的值后再相加以获得正确的性能评价用系统时
刻.

当存在定时器中断请求时,虽然可以将第二次读值替他第一次读值作为当前定时器
的值,但不满足要求(3),所以不采用.JSP内核所采用的方法不满足要求(4),所以也
不采用.

上面之所以用可以推测一词,是因为这种推测结果也有不成立的时候.此时可以分
为以下两种情况加以分析.

(a) 虽然第一次读值是定时器溢出之后的值但却大于第二次读值.

这种情况可能使由于处理器对定时器中断请求相应比较长,使得两次读值之间的时
间间隔太长,从而导致两次读值之间再次发生了溢出.也就是说,无法响应定时器中
断请求的时间比系统时钟周期还要长.这种情况下,系统时刻也无法被正确更新.

(b) 虽然一次读取值是定时器溢出之前的值但它却小于等于二次读取值.

这种情况发生在两次读值之间的间隔大于性能评价用定时器的一个周期的时候.当
定时器中断禁止的时间比系统时钟周期还长时,系统时刻也无法被正确更新.

以上两种情况相当于,或者由于定时器中断被长时间禁止,或者由于某个优先级比定
时器中断更高的中断处理时间过长,或者由于在仿真环境下仿真器进程长时间无法
被切换等理由,导致系统时刻不能被正确更新的状况.此类情况应加入服务调用的
注意事项中.

实际上,由于系统时刻的当前值没有保存在变量之中(高位虽然保存在current_time
变量之中,但低位没有保存),实际上使用的是下一个时钟滴答的系统时刻.因此,除
了定时器的值为溢出后的值的情况外,所求得的性能评价用系统时刻应减去一个系
统时钟的周期.虽然这会使服务调用的运行时间产生一些变动,但由于if部分的内容
只是一次常量减法运算(在编译器优化之后),造成的变动可以忽略不计.

为了在任何状态都可以调用该服务调用,因此通过SIL的全中断锁定机能实现该服
务调用内部的临界区.


@ 实现任务异常处理禁止标志enatex的实现理由

任务异常处理禁止标志为TCB中的enatex域(表示是否允许任务异常处理的状态).
该标志的名字为enatex而不为distex,是为了与JSP内核中任务切换禁止标志enadsp
保持一致性.

但由于ASP内核中已经将enadsp变更为disdsp,将enatex也变更为distex更为合理.

完
